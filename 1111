/* Контейнер меню */
.context-menu {
  background: #fff;
  border: 1px solid #ccc;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  padding: 4px;
  z-index: 10000;
}
/* Кнопки внутри меню */
.context-menu-button {
  display: block;
  width: 100%;
  padding: 4px 8px;
  background: none;
  border: none;
  text-align: left;
  cursor: pointer;
}
.context-menu-button:hover {
  background: #eef;
}
/* Подсветка выбранной строки */
.highlighted-row {
  background: rgba(100,200,255,0.3) !important;
}


// ==================== ГЛОБАЛЬНЫЕ ====================
let tableinf = [];       // сюда кладём данные из get_tasks.php
let selectedRow = null;  // DOM‑узел <tr>, по которому кликнули

// контейнер для контекст‑меню
const menuEl = document.getElementById('menuTd');
if (!menuEl) {
  console.error('Не найден <div id="menuTd"> для контекст‑меню!');
}
menuEl.style.position = 'absolute';
menuEl.style.display  = 'none';
menuEl.className      = 'context-menu';

// ==================== 1) ЗАГРУЗКА ТАБЛИЦЫ ====================
document.addEventListener('DOMContentLoaded', reloadTable);

async function reloadTable() {
  try {
    tableinf = await fetchDataFromServer();
  } catch (err) {
    console.error('Ошибка загрузки данных:', err);
    tableinf = [];
  }
  addRow();
  setupTableClick();
}

// ==================== 2) ФЕТЧ ИЗ PHP ====================
async function fetchDataFromServer() {
  const resp = await fetch('api/get_tasks.php');
  if (!resp.ok) throw new Error(resp.statusText);
  const data = await resp.json();
  // Приведём поля к тому, что ожидает addRow()
  return data.map(item => ({
    id_seq:       item.ID_SEQ,
    datnz:        item.DATNZ,
    nnz:          item.NNZ,
    ocher:        item.OCHER,
    position:     item.POSITION,
    priority:     item.PRIORITY,
    status:       item.STATUS,
    dzag1:        item.DZAG1,
    dzag2:        item.DZAG2,
    kol1p:        item.KOL1P,
    dlot:         item.DLOT,
    marked_count: item.MARKED_COUNT
    // … остальное по необходимости
  }));
}

// ==================== 3) ОТРИСОВКА СТРОК (addRow) ====================
function addRow() {
  const tbody = document.querySelector('#tableTZ0 tbody');
  if (!tbody) {
    console.warn('tbody не найден');
    return;
  }
  tbody.innerHTML = '';

  tableinf.forEach((row, i) => {
    const tr = document.createElement('tr');
    tr.dataset.index    = i;
    tr.dataset.priority = row.priority;
    tr.dataset.status   = row.status;

    // Формируем текст ячеек точно как у вас в старом коде
    const idText     = `${row.datnz} ${row.nnz} ${row.id_seq}`;
    const slabb      = `${row.dzag1}/${row.dzag2}`;
    const needCut    = `${row.kol1p||''}/${row.dlot||''}`;
    const statusText = row.priority == 1 ? 'Распределён' : 'Не распределён';

    const fields = [
      row.position || '',  // позиция
      idText,              // длинная строка
      row.nnmr || '',      // Марка (NNMR)
      slabb,               // Крат: / заготовок
      needCut,             // Нужно/факт
      row.marked_count || '', // Размечено
      statusText           // Статус
    ];

    fields.forEach(txt => {
      const td = document.createElement('td');
      td.textContent = txt;
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });
}

// ==================== 4) КЛИК ПО ТАБЛИЦЕ ====================
function setupTableClick() {
  document.removeEventListener('click', tableClick);
  document.addEventListener('click', tableClick);
}

function tableClick(e) {
  const tr = e.target.closest('tr');
  if (tr && tr.parentNode.tagName.toLowerCase() === 'tbody') {
    // кликнули именно по строке таблицы
    if (selectedRow) selectedRow.classList.remove('highlighted-row');
    selectedRow = tr;
    tr.classList.add('highlighted-row');
    // и показываем меню
    showMenu(tr, e.pageX, e.pageY);
  } else {
    hideMenu();
  }
}

// ==================== 5) КОНТЕКСТ‑МЕНЮ ====================
function showMenu(tr, pageX, pageY) {
  hideMenu();  // на всякий
  // получаем нужные данные из строки
  const idx      = +tr.dataset.index;
  const priority = +tr.dataset.priority;
  const status   = +tr.dataset.status;

  // наполняем menuEl
  menuEl.innerHTML = '';
  if (status !== 1) {    // если не «завершено»
    addBtn(menuEl, '↑ Вверх',    () => moveUp(idx));
    addBtn(menuEl, '↓ Вниз',     () => moveDown(idx));
    if (priority === 0) {
      addBtn(menuEl, 'Следующий ▶', () => promote(idx));
    } else {
      addBtn(menuEl, 'Отложить ⏸',  () => postpone(idx));
    }
    addBtn(menuEl, 'Закончить ✖',  () => finishTask(idx));
  }

  // Позиционируем рядом с курсором
  menuEl.style.top     = pageY + 'px';
  menuEl.style.left    = pageX + 'px';
  menuEl.style.display = 'block';

  // клик вне меню скроет его
  setTimeout(()=>{
    document.addEventListener('click', onDocClick);
  },0);
}

function hideMenu() {
  menuEl.style.display = 'none';
  if (selectedRow) {
    selectedRow.classList.remove('highlighted-row');
    selectedRow = null;
  }
  document.removeEventListener('click', onDocClick);
}

function onDocClick(e) {
  if (!menuEl.contains(e.target)) {
    hideMenu();
  }
}

function addBtn(container, label, fn) {
  const btn = document.createElement('button');
  btn.textContent = label;
  btn.className   = 'context-menu-button';
  btn.onclick     = async () => {
    await fn();
    hideMenu();
    await reloadTable();
  };
  container.appendChild(btn);
}

// ==================== 6) ДЕЙСТВИЯ, ВЫЗЫВАЮЩИЕ PHP ====================
async function moveUp(idx) {
  await postAction('move_up.php', tableinf[idx]);
}
async function moveDown(idx) {
  await postAction('move_down.php', tableinf[idx]);
}
async function promote(idx) {
  await postAction('promote.php', tableinf[idx]);
}
async function postpone(idx) {
  await postAction('postpone.php', tableinf[idx]);
}
async function finishTask(idx) {
  await postAction('finish.php', tableinf[idx]);
}

async function postAction(endpoint, payload) {
  await fetch(`api/${endpoint}`, {
    method: 'POST',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(payload)
  });
}






































Ниже полный набор всех PHP‑скриптов, которые нужны в папке api/:

1) api/db_connect.php
php
Копировать
Редактировать
<?php
// Подключение к Oracle
// Замените USERNAME, PASSWORD и CONNECTION_STRING на ваши реальные
$username          = 'YOUR_USERNAME';
$password          = 'YOUR_PASSWORD';
$connection_string = 'HOST:PORT/SERVICE_NAME'; 

// Пример CONNECTION_STRING: "dbhost.example.com:1521/OPTIM"
// В вашем случае вместо HOST:PORT/SERVICE_NAME подставьте то, что знаете.
// Если нужна SID, то "HOST:PORT/SID".

$conn = oci_connect($username, $password, $connection_string);
if (!$conn) {
    $e = oci_error();
    header('Content-Type: application/json', true, 500);
    echo json_encode(['error' => $e['message']]);
    exit;
}
?>
2) api/get_tasks.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
require __DIR__ . '/db_connect.php';

$sql = "
  SELECT 
    ID_SEQ,
    TO_CHAR(DATNZ,'YYYY-MM-DD') AS DATNZ,
    NNZ,
    OCHER,
    POSITION,
    PRIORITY,
    STATUS,
    DZAG1,
    DZAG2,
    KOL1P,
    DLOT,
    MARKED_COUNT
  FROM TS.T_TS_MNLZ2_TASK25
  ORDER BY 
    NVL(POSITION,9999),         -- сначала приоритетные, по позиции
    DATNZ, NNZ, OCHER, ID_SEQ   -- затем все остальные по дате/номеру/очереди
";

$stid = oci_parse($conn, $sql);
oci_execute($stid);

$out = [];
while ($row = oci_fetch_assoc($stid)) {
    $out[] = $row;
}

oci_free_statement($stid);
oci_close($conn);

echo json_encode($out, JSON_UNESCAPED_UNICODE);
3) api/move_up.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];  // формат YYYY-MM-DD
$nnz    = $data['nnz'];

$sql = "
  DECLARE
    cur_pos   NUMBER;
    other_id  TS.T_TS_MNLZ2_TASK25.ID_SEQ%TYPE;
    other_dn  TS.T_TS_MNLZ2_TASK25.DATNZ%TYPE;
    other_nn  TS.T_TS_MNLZ2_TASK25.NNZ%TYPE;
  BEGIN
    -- текущее положение
    SELECT POSITION 
      INTO cur_pos
      FROM TS.T_TS_MNLZ2_TASK25
     WHERE ID_SEQ = :id_seq
       AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
       AND NNZ    = :nnz;

    IF cur_pos > 1 THEN
      -- найдём задачу, у которой позиция = cur_pos-1
      SELECT ID_SEQ, DATNZ, NNZ
        INTO other_id, other_dn, other_nn
        FROM TS.T_TS_MNLZ2_TASK25
       WHERE PRIORITY = 1
         AND POSITION = cur_pos-1
       FOR UPDATE;

      -- обменяем позиции
      UPDATE TS.T_TS_MNLZ2_TASK25
         SET POSITION = cur_pos
       WHERE ID_SEQ = other_id
         AND DATNZ  = other_dn
         AND NNZ    = other_nn;

      UPDATE TS.T_TS_MNLZ2_TASK25
         SET POSITION = cur_pos-1
       WHERE ID_SEQ = :id_seq
         AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
         AND NNZ    = :nnz;
    END IF;
    COMMIT;
  END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
4) api/move_down.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
  DECLARE
    cur_pos   NUMBER;
    max_pos   NUMBER;
    other_id  TS.T_TS_MNLZ2_TASK25.ID_SEQ%TYPE;
    other_dn  TS.T_TS_MNLZ2_TASK25.DATNZ%TYPE;
    other_nn  TS.T_TS_MNLZ2_TASK25.NNZ%TYPE;
  BEGIN
    -- текущее положение и макс позицию среди priority=1
    SELECT POSITION, MAX(POSITION) 
      INTO cur_pos, max_pos
      FROM TS.T_TS_MNLZ2_TASK25
     WHERE PRIORITY = 1
     GROUP BY POSITION;

    IF cur_pos < max_pos THEN
      -- найдём задачу на cur_pos+1
      SELECT ID_SEQ, DATNZ, NNZ
        INTO other_id, other_dn, other_nn
        FROM TS.T_TS_MNLZ2_TASK25
       WHERE PRIORITY = 1
         AND POSITION = cur_pos+1
       FOR UPDATE;

      -- обмен позиций
      UPDATE TS.T_TS_MNLZ2_TASK25
         SET POSITION = cur_pos
       WHERE ID_SEQ = other_id
         AND DATNZ  = other_dn
         AND NNZ    = other_nn;

      UPDATE TS.T_TS_MNLZ2_TASK25
         SET POSITION = cur_pos+1
       WHERE ID_SEQ = :id_seq
         AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
         AND NNZ    = :nnz;
    END IF;
    COMMIT;
  END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
5) api/promote.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
  DECLARE
    v_max NUMBER;
  BEGIN
    -- сдвинем вниз всех текущих priority=1
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET POSITION = POSITION + 1
     WHERE PRIORITY = 1;

    -- найдём новую «голову»
    SELECT MAX(POSITION) 
      INTO v_max
      FROM TS.T_TS_MNLZ2_TASK25
     WHERE PRIORITY = 1;

    -- обновим саму запись
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET PRIORITY = 1,
           POSITION = 1
     WHERE ID_SEQ = :id_seq
       AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
       AND NNZ    = :nnz;

    COMMIT;
  END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
6) api/postpone.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
  BEGIN
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET PRIORITY = 0,
           POSITION = NULL
     WHERE ID_SEQ = :id_seq
       AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
       AND NNZ    = :nnz;
    COMMIT;
  END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
7) api/finish.php
php
Копировать
Редактировать
<?php
header('Content-Type: application/json; charset=UTF-8');
$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
  BEGIN
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET STATUS = 1
     WHERE ID_SEQ = :id_seq
       AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
       AND NNZ    = :nnz;
    COMMIT;
  END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
Кратко о каждом файле:

db_connect.php — единый вход в БД, коннект по OCI.

get_tasks.php — отдаёт JSON‑массив из T_TS_MNLZ2_TASK25.

move_up.php / move_down.php — меняют местами позиции двух priority=1 записей.

promote.php — делает задачу приоритетной (priority=1), вставляет её в начало списка (position=1), сдвигая остальных вниз.

postpone.php — снимает приоритет (priority=0), сбрасывает position.

finish.php — помечает задачу завершённой (status=1).

После этого ваш JS из предыдущего ответа будет работать «из коробки».



















1) api/promote.php
php
Копировать код
<?php
header('Content-Type: application/json; charset=UTF-8');
ini_set('display_errors',1);
error_reporting(E_ALL);

$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
DECLARE
  v_old_prio NUMBER;
  v_old_pos  NUMBER;
BEGIN
  -- Сначала захватим текущий приоритет и позицию этой задачи (если есть)
  SELECT PRIORITY, POSITION
    INTO v_old_prio, v_old_pos
    FROM TS.T_TS_MNLZ2_TASK25
   WHERE ID_SEQ = :id_seq
     AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
     AND NNZ    = :nnz
   FOR UPDATE;

  IF v_old_prio = 1 THEN
    -- Если она уже была в приоритете, сдвигаем вниз только тех, кто
    -- стоял выше неё (позиции < её старой позиции)
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET POSITION = POSITION + 1
     WHERE PRIORITY = 1
       AND POSITION < v_old_pos;
  ELSE
    -- Если она НЕ была приоритетной, сдвигаем вниз всех текущих
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET POSITION = POSITION + 1
     WHERE PRIORITY = 1;
  END IF;

  -- И, наконец, делаем эту задачу приоритетной и ставим её на позицию 1
  UPDATE TS.T_TS_MNLZ2_TASK25
     SET PRIORITY = 1,
         POSITION = 1
   WHERE ID_SEQ = :id_seq
     AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
     AND NNZ    = :nnz;

  COMMIT;
END;";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
2) api/postpone.php
php
Копировать код
<?php
header('Content-Type: application/json; charset=UTF-8');
ini_set('display_errors',1);
error_reporting(E_ALL);

$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
DECLARE
  v_old_pos NUMBER;
BEGIN
  -- Считаем, с какой позиции будем «вытаскивать» задачу
  SELECT POSITION
    INTO v_old_pos
    FROM TS.T_TS_MNLZ2_TASK25
   WHERE ID_SEQ = :id_seq
     AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
     AND NNZ    = :nnz
   FOR UPDATE;

  -- Снимаем приоритет и обнуляем позицию у нашей задачи
  UPDATE TS.T_TS_MNLZ2_TASK25
     SET PRIORITY = 0,
         POSITION = NULL
   WHERE ID_SEQ = :id_seq
     AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
     AND NNZ    = :nnz;

  -- Сдвигаем «вверх» всех, кто стоял ниже отложенной (позиции > v_old_pos)
  UPDATE TS.T_TS_MNLZ2_TASK25
     SET POSITION = POSITION - 1
   WHERE PRIORITY = 1
     AND POSITION > v_old_pos;

  COMMIT;
END;";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok'=>true]);
Краткое пояснение логики
promote.php

Читает старые PRIORITY и POSITION для выбранной задачи.

Если задача уже была приоритетной, то сдвигает вниз (позицию+1) всех, кто стоял выше неё (позиции < старой).
Если ещё не была — сдвигает вниз всех приоритетных сразу.

Обновляет саму задачу: PRIORITY=1, POSITION=1.

Коммитит.

postpone.php

Читает старую POSITION выбранной задачи.

Снимает у неё приоритет и обнуляет позицию (PRIORITY=0, POSITION=NULL).

Сдвигает вверх (позицию–1) всех приоритетных задач, которые стояли ниже отложенной (позиции > старая).

Коммитит.

Эти две процедуры теперь поддерживают ровную перестановку при добавлении («Следующий») и удалении («Отложить») из приоритетного списка.




















<?php
header('Content-Type: application/json; charset=UTF-8');
ini_set('display_errors', 1);
error_reporting(E_ALL);

$data = json_decode(file_get_contents('php://input'), true);
require __DIR__ . '/db_connect.php';

$id_seq = $data['id_seq'];
$datnz  = $data['datnz'];
$nnz    = $data['nnz'];

$sql = "
DECLARE
  cur_pos     NUMBER;
  max_pos     NUMBER;
  other_id    TS.T_TS_MNLZ2_TASK25.ID_SEQ%TYPE;
  other_dn    TS.T_TS_MNLZ2_TASK25.DATNZ%TYPE;
  other_nn    TS.T_TS_MNLZ2_TASK25.NNZ%TYPE;
BEGIN
  -- 1) Узнаём текущую позицию нашей задачи
  SELECT POSITION
    INTO cur_pos
    FROM TS.T_TS_MNLZ2_TASK25
   WHERE ID_SEQ = :id_seq
     AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
     AND NNZ    = :nnz
   FOR UPDATE;

  -- 2) Узнаём, сколько всего приоритетных задач
  SELECT MAX(POSITION)
    INTO max_pos
    FROM TS.T_TS_MNLZ2_TASK25
   WHERE PRIORITY = 1;

  -- 3) Если мы не на самом низу — меняем местами с задачей ниже
  IF cur_pos < max_pos THEN

    -- найдём запись, у которой POSITION = cur_pos+1
    SELECT ID_SEQ, DATNZ, NNZ
      INTO other_id, other_dn, other_nn
      FROM TS.T_TS_MNLZ2_TASK25
     WHERE PRIORITY = 1
       AND POSITION = cur_pos + 1
     FOR UPDATE;

    -- сдвинем «соседа» вверх (заняв нашу позицию)
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET POSITION = cur_pos
     WHERE ID_SEQ = other_id
       AND DATNZ  = other_dn
       AND NNZ    = other_nn;

    -- а нашу задачу вниз
    UPDATE TS.T_TS_MNLZ2_TASK25
       SET POSITION = cur_pos + 1
     WHERE ID_SEQ = :id_seq
       AND DATNZ  = TO_DATE(:datnz,'YYYY-MM-DD')
       AND NNZ    = :nnz;
  END IF;

  COMMIT;
END;
";

$stid = oci_parse($conn, $sql);
oci_bind_by_name($stid, ':id_seq', $id_seq);
oci_bind_by_name($stid, ':datnz',  $datnz);
oci_bind_by_name($stid, ':nnz',    $nnz);
oci_execute($stid);
oci_free_statement($stid);
oci_close($conn);

echo json_encode(['ok' => true]);







Новый API-эндпоинт api/get_signal_data.php
Этот скрипт читает signal_log.txt, парсит каждую строку и возвращает JSON-массив объектов вида

js
Копировать код
{ 
  datetime: "2025-05-15T12:34:56",
  mgrPos:   12345,
  burner1:  234,
  burner2:  345,
  indicator:456,
  ingotLen: 567,
  cutTask:  678
}
php
Копировать код
<?php
// api/get_signal_data.php

header('Content-Type: application/json; charset=UTF-8');
$logFile = __DIR__ . '/../signal_log.txt';
if (!file_exists($logFile)) {
    echo json_encode([]);
    exit;
}

$lines = file($logFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
$out   = [];

foreach ($lines as $line) {
    // Формат:
    // Дата и время: YYYY-MM-DD HH:MM:SS  позиция мгр:VAL, горелка1 привод старт:VAL, горелка2 привод старт:VAL, индикатор фактической длины:VAL, длина слитка при разливке:VAL, задание на порез:VAL
    if (preg_match('/Дата и время:\s*(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\s+позиция мгр:(\S+),\s*горелка1 привод старт:(\S+),\s*горелка2 привод старт:(\S+),\s*индикатор фактической длины:(\S+),\s*длина слитка при разливке:(\S+),\s*задание на порез:(\S+)/u', $line, $m)) {
        $out[] = [
            'datetime'  => str_replace(' ', 'T', $m[1]),
            'mgrPos'    => (float)$m[2],
            'burner1'   => (float)$m[3],
            'burner2'   => (float)$m[4],
            'indicator' => (float)$m[5],
            'ingotLen'  => (float)$m[6],
            'cutTask'   => (float)$m[7],
        ];
    }
}

// возвращаем JSON
echo json_encode($out, JSON_UNESCAPED_UNICODE);
2. Страница с графиком chart.php
php
Копировать код
<?php
// chart.php
?><!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>График сигналов</title>
  <link rel="stylesheet" href="chart.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>График параметров МГР1.Позиция и др.</h1>
  <div class="chart-container">
    <canvas id="signalChart"></canvas>
  </div>
  <script>
  console.group('Chart Page');

  async function fetchData() {
    console.log('Запрос в api/get_signal_data.php …');
    const resp = await fetch('api/get_signal_data.php');
    console.log('HTTP', resp.status, resp.statusText);
    const data = await resp.json();
    console.log('Получены данные:', data);
    return data;
  }

  function buildChart(data) {
    console.log('Строим график из', data.length, 'точек');
    const ctx = document.getElementById('signalChart').getContext('2d');
    const labels = data.map(d => d.datetime);
    const series = {
      mgrPos:    data.map(d=>d.mgrPos),
      burner1:   data.map(d=>d.burner1),
      burner2:   data.map(d=>d.burner2),
      indicator: data.map(d=>d.indicator),
      ingotLen:  data.map(d=>d.ingotLen),
      cutTask:   data.map(d=>d.cutTask),
    };

    new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label:'Позиция МГР',          data: series.mgrPos,    fill:false },
          { label:'Горелка1 привод старт',data: series.burner1,   fill:false },
          { label:'Горелка2 привод старт',data: series.burner2,   fill:false },
          { label:'Индикатор длины',      data: series.indicator, fill:false },
          { label:'Длина слитка',         data: series.ingotLen,  fill:false },
          { label:'Задание на порез',     data: series.cutTask,   fill:false },
        ]
      },
      options: {
        responsive: true,
        interaction: { mode:'index', intersect:false },
        stacked: false,
        plugins: {
          title: { display:true, text:'Параметры по времени' },
          legend: { position:'bottom' }
        },
        scales: {
          x: {
            type:'time',
            time: {
              parser:'yyyy-MM-dd\'T\'HH:mm:ss',
              tooltipFormat:'dd.MM.yyyy HH:mm:ss',
              unit:'minute',
              displayFormats:{ minute:'HH:mm' }
            },
            title: { display:true, text:'Время' }
          },
          y: {
            title: { display:true, text:'Значение' }
          }
        }
      }
    });
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const data = await fetchData();
    buildChart(data);
    console.groupEnd();
  });
  </script>
</body>
</html>
3. Стили для страницы графика chart.css
css
Копировать код
body {
  font-family: Arial, sans-serif;
  margin: 20px;
}
h1 {
  text-align: center;
  margin-bottom: 16px;
}
.chart-container {
  position: relative;
  width: 90%;
  max-width: 1000px;
  height: 500px;
  margin: 0 auto;
}
Как это работает
get_signal_data.php собирает из signal_log.txt структурированные данные.

chart.php загружает Chart.js, делает AJAX в get_signal_data.php, получает массив объектов, и строит многосерийный линейный график:

по оси X — время (datetime),

по оси Y — значения каждого параметра.

chart.css задаёт контейнер нужного размера и центрирует его.

Теперь у вас в проекте есть вторая страница (chart.php), на которой в реальном времени (при перезагрузке) отображается график по всем вашим сигналам.









позиция мгр: 12345")

php
Копировать код
<?php
// api/get_signal_log.php

header('Content-Type: application/json; charset=UTF-8');
$logFile = __DIR__ . '/../signal_log.txt';
$lines = [];

if (file_exists($logFile)) {
  $lines = file($logFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
}

echo json_encode($lines, JSON_UNESCAPED_UNICODE);
2. index.php
php
Копировать код
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Signal Logger + График</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <h1>Логи сигнала МГР1.Позиция.</h1>
  <div id="status">Статус: <em>ожидание...</em></div>

  <table id="logTable">
    <thead>
      <tr><th>#</th><th>Запись</th></tr>
    </thead>
    <tbody id="logBody"></tbody>
  </table>

  <h2>График «позиции МГР»</h2>
  <canvas id="signalChart" width="800" height="300"></canvas>

  <script>
  // === Парсер одной строки лога ===
  function parseLine(line) {
    // Ожидаем: "Дата и время: YYYY-MM-DD HH:MM:SS  позиция мгр: VALUE"
    const dtMatch = line.match(/Дата и время:\s*(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
    const valMatch= line.match(/позиция мгр:\s*(\d+)/);
    return {
      time: dtMatch ? new Date(dtMatch[1]) : null,
      value: valMatch ? Number(valMatch[1]) : null,
      raw: line
    };
  }

  // === Загружает и рисует таблицу и график ===
  async function loadAndDraw() {
    console.group('loadAndDraw');
    try {
      const resp = await fetch('api/get_signal_log.php');
      console.log('Fetch status', resp.status);
      const lines = await resp.json();
      console.log('Получили строки:', lines);

      // 1) Заполним таблицу
      const tbody = document.getElementById('logBody');
      tbody.innerHTML = '';
      const data = []; // для графика
      lines.forEach((line, i) => {
        const p = parseLine(line);
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${p.raw}</td>`;
        tbody.appendChild(tr);
        if (p.time && p.value !== null) data.push(p);
      });
      document.getElementById('status').textContent = 
        `Статус: загружено ${data.length} точек`;

      // 2) Нарисуем график
      drawChart(data);
    } catch(e) {
      console.error('Ошибка loadAndDraw:', e);
      document.getElementById('status').textContent = 'Статус: ошибка';
    }
    console.groupEnd();
  }

  // === Рисует простой линейный график в canvas ===
  function drawChart(data) {
    console.group('drawChart');
    const canvas = document.getElementById('signalChart');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    if (data.length < 2) {
      console.warn('Недостаточно точек для графика');
      return;
    }

    // Находим мин/макс по времени и значению
    const times = data.map(p=>p.time.getTime());
    const vals  = data.map(p=>p.value);
    const tMin  = Math.min(...times), tMax = Math.max(...times);
    const vMin  = Math.min(...vals),  vMax = Math.max(...vals);

    // Отступы
    const margin = { top:20, bottom:30, left:50, right:20 };
    const plotW = W - margin.left - margin.right;
    const plotH = H - margin.top - margin.bottom;

    // Функции масштабирования
    const xScale = t => margin.left + ((t - tMin)/(tMax - tMin))*plotW;
    const yScale = v => margin.top + plotH - ((v - vMin)/(vMax - vMin))*plotH;

    // Оси
    ctx.strokeStyle = '#000';
    ctx.beginPath();
    // Y-axis
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + plotH);
    // X-axis
    ctx.moveTo(margin.left, margin.top + plotH);
    ctx.lineTo(margin.left + plotW, margin.top + plotH);
    ctx.stroke();

    // Подписи по Y (значения)
    ctx.fillStyle = '#000';
    ctx.textAlign = 'right';
    for (let i=0; i<=5; i++) {
      const v = vMin + (vMax - vMin)*(i/5);
      const y = yScale(v);
      ctx.fillText(v.toFixed(0), margin.left-5, y+3);
      ctx.beginPath();
      ctx.moveTo(margin.left-3,y);
      ctx.lineTo(margin.left,y);
      ctx.stroke();
    }

    // Подписи по X (время)
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let i=0; i<=5; i++){
      const t = tMin + (tMax-tMin)*(i/5);
      const x = xScale(t);
      const dt = new Date(t);
      const label = dt.toTimeString().substr(0,5);
      ctx.fillText(label, x, margin.top+plotH+5);
      ctx.beginPath();
      ctx.moveTo(x, margin.top+plotH);
      ctx.lineTo(x, margin.top+plotH+3);
      ctx.stroke();
    }

    // Линия графика
    ctx.strokeStyle = 'blue';
    ctx.beginPath();
    data.forEach((p, idx) => {
      const x = xScale(p.time.getTime());
      const y = yScale(p.value);
      if (idx === 0) ctx.moveTo(x,y);
      else           ctx.lineTo(x,y);
    });
    ctx.stroke();

    console.groupEnd();
  }

  // === Запуск ===
  document.addEventListener('DOMContentLoaded', () => {
    console.group('Page init');
    loadAndDraw();
    // обновляем каждые 5 секунд
    setInterval(loadAndDraw, 5000);
    console.groupEnd();
  });
  </script>
</body>
</html>
3. style.css
css
Копировать код
body {
  font-family: Arial, sans-serif;
  margin: 20px;
}
h1, h2 {
  margin-bottom: 10px;
}
#status {
  margin-bottom: 12px;
  font-style: italic;
}
#logTable {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 20px;
}
#logTable th, #logTable td {
  border: 1px solid #ccc;
  padding: 6px 8px;
}
#logTable thead {
  background: #f0f0f0;
}
#logTable tbody tr:nth-child(even) {
  background: #fafafa;
}
#signalChart {
  border: 1px solid #999;
  background: #fff;
}
Как это работает
loadAndDraw() каждый 5 секунд подгружает логи (JSON) и заполняет таблицу.

drawChart(data) рисует оси, подписи и соединяет точки чистым Canvas API.

parseLine() извлекает дату и численное значение из вашей строки.

Всё на “vanilla” JS и HTML5 Canvas — без единой внешней библиотеки. Теперь вы увидите не только табличный лог, но и график изменения «позиции МГР» во времени.















запрашиваемым параметрам.

1. api/get_signal_log.php
(никаких изменений, он отдаёт массив строк уже в формате

php
Копировать код
Дата и время: YYYY-MM-DD HH:MM:SS  позиция мгр:V355, горелка1 привод старт:V364, …, задание на порез:V393
```)

```php
<?php
// api/get_signal_log.php
header('Content-Type: application/json; charset=UTF-8');
$logFile = __DIR__ . '/../signal_log.txt';
$lines = [];

if (file_exists($logFile)) {
  $lines = file($logFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
}

echo json_encode($lines, JSON_UNESCAPED_UNICODE);
2. index.php
php
Копировать код
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Signal Logger + Multi-Chart</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <h1>Логи сигнала МГР1.Позиция. и прочих параметров</h1>
  <div id="status">Статус: ожидание…</div>

  <table id="logTable">
    <thead>
      <tr><th>#</th><th>Запись</th></tr>
    </thead>
    <tbody id="logBody"></tbody>
  </table>

  <h2>График всех параметров</h2>
  <canvas id="signalChart" width="900" height="400"></canvas>

  <script>
  // Цвета для каждой кривой
  const COLORS = {
    p355: 'red',    // позиция МГР
    p364: 'orange', // горелка1
    p361: 'green',  // горелка2
    p370: 'blue',   // индикатор длины
    p376: 'purple', // длина слитка
    p393: 'brown'   // задание на порез
  };

  // Парсим строку лога в объект {time:Date, vals:{p355:…,p364:…,...}, raw:…}
  function parseLine(line) {
    const timeMatch = line.match(/Дата и время:\s*(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
    const date = timeMatch ? new Date(timeMatch[1]) : null;
    const vals = {};
    ['355','364','361','370','376','393'].forEach(id=>{
      const re = new RegExp(id=== '355'
        ? `позиция мгр:\\s*(\\d+)`
        : id==='364'
          ? `горелка1 привод старт:\\s*(\\d+)`
          : id==='361'
            ? `горелка2 привод старт:\\s*(\\d+)`
            : id==='370'
              ? `индикатор фактической длины:\\s*(\\d+)`
              : id==='376'
                ? `длина слитка при разливке:\\s*(\\d+)`
                : `задание на порез:\\s*(\\d+)`
      );
      const m = line.match(re);
      vals['p'+id] = m ? Number(m[1]) : null;
    });
    return { time: date, vals, raw: line };
  }

  // Загрузка лога и обновление таблицы + графика
  async function loadAndDraw() {
    console.group('loadAndDraw');
    try {
      const resp = await fetch('api/get_signal_log.php');
      console.log('fetch status', resp.status);
      const lines = await resp.json();
      console.log('lines:', lines);

      // Таблица
      const tbody = document.getElementById('logBody');
      tbody.innerHTML = '';
      const data = [];
      lines.forEach((ln,i) => {
        const p = parseLine(ln);
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${p.raw}</td>`;
        tbody.appendChild(tr);
        if (p.time) data.push(p);
      });
      document.getElementById('status').textContent = 
        `Статус: загружено ${data.length} точек`;

      // Рисуем многокривую
      drawChart(data);
    } catch(e) {
      console.error('Ошибка loadAndDraw:', e);
      document.getElementById('status').textContent = 'Статус: ошибка';
    }
    console.groupEnd();
  }

  // Рисуем все кривые
  function drawChart(data) {
    console.group('drawChart');
    const canvas = document.getElementById('signalChart');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    if (data.length < 2) {
      console.warn('Недостаточно данных');
      return;
    }

    // Масштаб времени и значений
    const times = data.map(p=>p.time.getTime());
    const tMin = Math.min(...times), tMax = Math.max(...times);
    // соберём все значения по всем параметрам
    const allVals = [];
    data.forEach(p=>{
      Object.values(p.vals).forEach(v=>{ if (v!==null) allVals.push(v); });
    });
    const vMin = Math.min(...allVals), vMax = Math.max(...allVals);

    // Отступы
    const m = {left:60, right:20, top:20, bottom:40};
    const plotW = W - m.left - m.right;
    const plotH = H - m.top - m.bottom;

    // Шкалы
    const xS = t => m.left + (t - tMin)/(tMax-tMin)*plotW;
    const yS = v => m.top + plotH - (v - vMin)/(vMax-vMin)*plotH;

    // Оси
    ctx.strokeStyle='#000'; ctx.beginPath();
    ctx.moveTo(m.left,m.top); ctx.lineTo(m.left,m.top+plotH);
    ctx.moveTo(m.left,m.top+plotH); ctx.lineTo(m.left+plotW,m.top+plotH);
    ctx.stroke();

    // Подписи Y
    ctx.fillStyle='#000'; ctx.textAlign='right';
    for(let i=0;i<=5;i++){
      const v=vMin+(vMax-vMin)*(i/5), y=yS(v);
      ctx.fillText(v.toFixed(0),m.left-5,y+3);
      ctx.beginPath(); ctx.moveTo(m.left-3,y); ctx.lineTo(m.left,y); ctx.stroke();
    }

    // Подписи X
    ctx.textAlign='center'; ctx.textBaseline='top';
    for(let i=0;i<=5;i++){
      const t=tMin+(tMax-tMin)*(i/5), x=xS(t);
      const dt=new Date(t);
      const label=dt.toTimeString().substr(0,5);
      ctx.fillText(label,x,m.top+plotH+5);
      ctx.beginPath(); ctx.moveTo(x,m.top+plotH); ctx.lineTo(x,m.top+plotH+3); ctx.stroke();
    }

    // Рисуем кривые для каждого параметра
    Object.keys(COLORS).forEach(key => {
      ctx.strokeStyle = COLORS[key];
      ctx.beginPath();
      data.forEach((p, idx) => {
        const v = p.vals[key];
        if (v===null) return;
        const x=xS(p.time.getTime()), y=yS(v);
        idx===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      });
      ctx.stroke();
    });

    // Легенда
    let lx = m.left + 10, ly = m.top + 5;
    ctx.textAlign='left'; ctx.textBaseline='middle';
    Object.entries(COLORS).forEach(([key,col])=>{
      ctx.fillStyle=col;
      ctx.fillRect(lx,ly-6,12,12);
      ctx.fillStyle='#000';
      ctx.fillText(key, lx+18, ly);
      ly += 18;
    });
    console.groupEnd();
  }

  // Инициация
  document.addEventListener('DOMContentLoaded', ()=>{
    console.group('Page init');
    loadAndDraw();
    setInterval(loadAndDraw, 5000);
    console.groupEnd();
  });
  </script>
</body>
</html>
3. style.css
css
Копировать код
body {
  font-family: Arial, sans-serif;
  margin: 20px;
}
h1, h2 {
  margin-bottom: 10px;
}
#status {
  margin-bottom: 12px;
  font-style: italic;
}
#logTable {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 20px;
}
#logTable th, #logTable td {
  border: 1px solid #ccc;
  padding: 6px 8px;
}
#logTable thead {
  background: #f0f0f0;
}
#logTable tbody tr:nth-child(even) {
  background: #fafafa;
}
#signalChart {
  border: 1px solid #999;
  background: #fff;
}
Как это работает
Парсинг: из каждой строки берем дату и 6 значений (p355, p364, … p393).

Таблица: всё ещё показывает «сырые» строки.

Canvas-график:

Одна система координат (время по X, значение по Y).

Шесть кривых, каждая своим цветом.

Легенда в левом верхнем углу (key соответствует метке, например, p355).

Всё чисто на «ванильном» Canvas API, без внешних библиотек. При каждом обновлении (каждые 5 сек) красным рисуется p355, оранжевым — p364 и т. д.
















ChatGPT может допускать ошибки. Проверьте важную информацию. См. настр
ChatGPT может допускать ошибки. Проверьте важную информацию. См. настройки co






ChatGPT может допускать ошибки. Проверьте важную информацию. См. настройк


