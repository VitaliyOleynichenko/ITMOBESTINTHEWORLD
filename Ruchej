Описание логики процесса расчёта длины ручья МНЛЗИсходные данные:

Сигнал 1: «Длина слитка при разливке и выводе отлитой заготовки» — монотонно растущая величина, которая отражает текущую длину слитка с момента начала литья. Значение никогда не уменьшается.

Сигнал 2: «Позиция в мм» — позиция газовой горелки, которая режет слиток.

Сигнал 3: «Факт рез (по энкодеру)» — длина, зафиксированная энкодером в момент реза.

Логика процесса:

Отслеживание длины слитка:
Значение «Длина слитка» постоянно увеличивается в процессе литья.

Мониторинг сигнала «Позиция в мм» газовой горелки:

Если позиция горелки растёт, это означает, что горелка движется вместе со слитком и происходит процесс резки.

Если позиция горелки начинает уменьшаться, значит резка завершена, и горелка возвращается в исходную позицию.

Определение момента окончания реза:
Момент, когда «Позиция в мм» начинает уменьшаться, фиксируется как событие завершения реза.

Расчёт длины ручья:
В момент начала уменьшения «Позиции в мм» берётся текущее значение «Длина слитка» (обозначим его L_общ) и из него вычитается значение «Факт рез (по энкодеру)» (обозначим его L_рез):

Lручья=Lобщ−LрезLручья=Lобщ−L









Описание логики:
1. В исходных данных
Сигнал «Длина слитка» (L_общ)

Монотонно растёт от нуля с начала литья и никогда не уменьшается.

Сигнал «Позиция газовой горелки» (pos)

Плавно меняется: при движении горелки вдоль слитка растёт, при возврате — убывает.

Сигнал «Факт реза (энкодер)» (L_рез_энк)

При завершении реза энкодер выдаёт длину сдвига горелки за время резки.

2. Цель алгоритма
В каждый момент окончания резки (когда горелка, доходя до точки разреза, разворачивается и начинает возвращаться назад) вычислять актуальную длину «ручья» — то есть расстояние от точки начала литья до точки, где сейчас стоит горелка.

3. Основные идеи
Накопление отрезанного материала. Вместо того, чтобы пытаться «сбросить» или «уменьшить» общую длину слитка, мы будем хранить сумму всех ранее отрезанных кусков.

Выявление момента окончания резки. Резка идёт, когда позиция горелки растёт. Как только позиция прекращает расти и начинает уменьшаться, это и есть сигнал окончания конкретного реза.

Расчёт длины ручья. В момент окончания реза берём текущее значение общей длины, вычитаем из него сумму всех ранее отрезанных кусков — получаем именно ту часть слитка, которая ещё не отрезана, то есть «ручей».

4. Перечень хранимых величин
L_общ — текущая, постоянно растущая длина слитка (сигнал).

pos — текущая позиция горелки (сигнал).

L_рез_энк — длина, отрезанная за последний цикл резки (по энкодеру).

cumLрез — накопленная суммарная длина всех отрезанных до текущего момента кусков (начинается с нуля).

prevPos — значение pos в предыдущей итерации (для определения направления).

prevDir — направление движения в предыдущий раз (+1 резка, –1 возврат, 0 покой).

L_ручья — вычисляемая в момент окончания реза длина «ручья».

5. Подробная текстовая схема работы
Инициализация перед началом процесса

Устанавливаем cumLрез = 0.

Сохраняем первое поступившее pos в prevPos.

Задаём prevDir = 0 (горелка ещё неподвижна).

Периодическое обновление (каждые несколько миллисекунд)

Определение текущего направления движения

Если pos > prevPos, значит горелка движется вперёд (режет) → dir = +1.

Если pos < prevPos, значит горелка возвращается обратно → dir = –1.

Если pos == prevPos, направление не меняется → dir = prevDir.

Обнаружение момента завершения резки

Если в предыдущей итерации было prevDir = +1, а в текущей стало dir = –1, значит именно сейчас закончился очередной цикл резки.

Вычисление длины «ручья» (при обнаружении конца резки)

Читаем текущее значение общей длины слитка → currentLобщ.

Читаем значение «факта реза» → currentLрез = L_рез_энк.

Прибавляем currentLрез к накопленной сумме:

text
Копировать
cumLрез := cumLрез + currentLрез
Вычисляем актуальную длину «ручья»:

text
Копировать
L_ручья := currentLобщ − cumLрез
Теперь L_ручья отражает длину не отрезанной части слитка после этого реза.

Обновление «прошлого» состояния для следующей итерации

prevPos := pos

prevDir := dir

Использование результата

После каждого завершения резки в переменной L_ручья всегда находится актуальное расстояние от стартовой точки литья до текущей позиции горелки.

Эту величину можно передавать во внешние системы (SCADA, базу данных, оператору и т. д.) для контроля длины «ручья» в реальном времени.

6. Дополнительные рекомендации
Защита от дребезга и шумов:
Если сигнал pos прыгает или дребезжит, перед расчётом направления движения можно ввести небольшую «мертвую зону» (например, учитывать изменение только при превышении порога Δ = 0.5 мм).

Логирование:
Для отладки полезно записывать в лог:

Время события,

currentLобщ, currentLрез, текущее и накопленное cumLрез,

Результирующее L_ручья.

Мониторинг целостности:
Проверять, что cumLрез никогда не превышает currentLобщ и что L_ручья остаётся неотрицательным.









Логика на примере:
Переменные и сигналы
Сигнал1 L_общ — «длина слитка» (монотонно растёт, никогда не уменьшается).

Сигнал2 pos — позиция газовой горелки (в мм).

Сигнал3 L_рез_энк — «факт реза» по энкодеру: длина, на которую сдвинулась горелка за время реза.

Вспомогательные переменные
cumLрез = 0 — накопленная суммарная длина всех отрезанных кусков.

prevPos — предыдущее значение pos (для определения направления движения).

prevDir — предыдущее направление движения горелки:

+1 — шла вперёд (по слитку, режет)

0 — стояла

−1 — возвращалась

L_ручья — текущая длина ручья (то, что мы считаем и выдаём).

prevLобщ — значение L_общ при предыдущем расчёте (необязательно, для контроля и отладки).

Логика и порядок вычислений
Инициализация (перед стартом литья)

text
Копировать
cumLрез   := 0
prevPos   := pos (первое попадание сигнала)
prevDir   := 0
prevLобщ  := L_общ (обычно = 0)
L_ручья   := 0
Основной цикл (например, каждую 10…50 мс)

text
Копировать
// 2.1. Считаем текущее направление движения горелки:
if pos > prevPos then
    dir := +1      // горелка движется «вдоль» слитка — идёт резка
else if pos < prevPos then
    dir := -1      // горелка возвращается — резка закончена
else
    dir := prevDir // без изменения
Обнаружение момента ОКОНЧАНИЯ резки
Событие «резка только что завершилась» — переход движения из +1 в −1:

text
Копировать
if prevDir == +1 and dir == -1 then
    // --- начало обработки события «конец реза» ---
    currentLобщ := L_общ
    currentLрез := L_рез_энк

    // 3.1. Накопление суммарной отрезанной длины
    cumLрез := cumLрез + currentLрез

    // 3.2. Расчёт новой длины ручья
    //   — из всей отлитой длины вычитаем всё, что уже отрезано
    L_ручья := currentLобщ - cumLрез

    // 3.3. (Опционально) для отладки можно смотреть дельту:
    delta := currentLобщ - prevLобщ
    //     обычно delta ≈ currentLрез  (если подача слитка при резке приостанавливается)

    // 3.4. Сохраняем «старую» общую длину
    prevLобщ := currentLобщ

    // 3.5. Здесь можно логировать:
    //     Время, currentLобщ, currentLрез, cumLрез, L_ручья, delta

    // --- конец обработки события ---
end if
Обновление «прошлого» состояния

text
Копировать
prevPos := pos
prevDir := dir
Использование результата

После каждого срабатывания события «конец реза» переменная L_ручья содержит актуальную длину ручья.

При желании её можно выдавать в SCADA/HMI или отправлять на запись в базу.

Пояснения
Мы накопляем в cumLрез все длины отрезанных кусков, поэтому при любом следующем расчёте достаточно взять из кумулятивной отлитой длины вычитание именно этой суммы.

Нет необходимости «сбрасывать» или уменьшать L_общ — он всегда растёт, а всю логику «отнятия» мы выносим в cumLрез.

Направление движения детектируется по изменению pos: рост = резка, спад = возврат. Переход «резка→возврат» и есть признак окончания разового реза.

Для устойчивости к «дребезгу» датчика позиции можно добавить небольшую зону нечувствительности (hysteresis) или условие минимальной скорости движения.







Процедура:
Таблица для хранения состояния процесса (stream_state)

Таблица для логирования результатов (ruchya_log)

Процедура process_stream — её вызывают при каждом новом приёме сигналов (L_общ, pos, L_рез_энк)

sql
Копировать
-- 1. Таблица для хранения текущего состояния алгоритма
--    В ней единственная строка с id = 1, хранящая кумулятивные и предыдущие значения
CREATE TABLE stream_state (
  id           NUMBER        PRIMARY KEY,
  cum_lrez     NUMBER        DEFAULT 0,     -- накопленная длина отрезанных кусков
  prev_pos     NUMBER        DEFAULT NULL,  -- предыдущая позиция горелки
  prev_dir     PLS_INTEGER   DEFAULT 0,     -- предыдущий признак движения: +1, 0, -1
  prev_lobj    NUMBER        DEFAULT 0     -- предыдущая общая длина (для отладки)
);

-- Инициализируем единственную строку
INSERT INTO stream_state(id) VALUES (1);
COMMIT;


-- 2. Таблица для логирования каждого вычисления длины ручья
CREATE TABLE ruchya_log (
  log_time     TIMESTAMP     DEFAULT SYSTIMESTAMP,
  lobj         NUMBER,        -- текущее значение L_общ
  lrez_enc     NUMBER,        -- текущий факт реза
  cum_lrez     NUMBER,        -- обновлённое накопленное L_рез
  l_ruchya     NUMBER         -- рассчитанная длина ручья
);


-- 3. Процедура, реализующая логику
CREATE OR REPLACE PROCEDURE process_stream(
    p_lobj       IN  NUMBER,          -- сигнал «Длина слитка»
    p_pos        IN  NUMBER,          -- сигнал «Позиция горелки»
    p_lrez_enc   IN  NUMBER,          -- сигнал «Факт реза» по энкодеру
    p_lruchya    OUT NUMBER           -- выход: вычисленная длина ручья (NULL, если не произошло окончания реза)
) IS
  -- локальные переменные для состояния
  v_cum_lrez   NUMBER;
  v_prev_pos   NUMBER;
  v_prev_dir   PLS_INTEGER;
  v_prev_lobj  NUMBER;
  v_dir        PLS_INTEGER;
BEGIN
  -- 3.1. Заблокировать и прочитать текущее состояние
  SELECT cum_lrez, prev_pos, prev_dir, prev_lobj
    INTO v_cum_lrez, v_prev_pos, v_prev_dir, v_prev_lobj
    FROM stream_state
   WHERE id = 1
     FOR UPDATE;

  -- 3.2. Определяем текущее направление движения горелки
  IF v_prev_pos IS NULL THEN
    -- первый вызов, направление не определено
    v_dir := 0;
  ELSIF p_pos > v_prev_pos THEN
    v_dir :=  1;  -- резка (движение вперёд)
  ELSIF p_pos < v_prev_pos THEN
    v_dir := -1;  -- возврат (движение назад)
  ELSE
    v_dir := v_prev_dir;  -- без изменения
  END IF;

  -- По умолчанию длина ручья не вычисляется
  p_lruchya := NULL;

  -- 3.3. Обнаружение момента окончания резки: переход +1 → -1
  IF v_prev_dir = 1 AND v_dir = -1 THEN
    -- накопим новую порцию отрезанной длины
    v_cum_lrez := v_cum_lrez + p_lrez_enc;

    -- рассчитаем длину ручья
    p_lruchya := p_lobj - v_cum_lrez;

    -- залогируем результат
    INSERT INTO ruchya_log(lobj, lrez_enc, cum_lrez, l_ruchya)
      VALUES (p_lobj, p_lrez_enc, v_cum_lrez, p_lruchya);
  END IF;

  -- 3.4. Обновляем состояние для следующего вызова
  UPDATE stream_state
     SET cum_lrez  = v_cum_lrez,
         prev_pos  = p_pos,
         prev_dir  = v_dir,
         prev_lobj = p_lobj
   WHERE id = 1;

  COMMIT;  -- сохраняем новое состояние и лог

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;  -- прокидываем ошибку дальше
END process_stream;
/
Как пользоваться
По приходу каждого нового «среза» сигналов просто вызвать

sql
Копировать
DECLARE
  v_ruchya NUMBER;
BEGIN
  process_stream(
    p_lobj     => :текущий_Lобщ,
    p_pos      => :текущая_pos,
    p_lrez_enc => :текущий_Lрез_энк,
    p_lruchya  => v_ruchya
  );
  -- если v_ruchya IS NOT NULL, значит сейчас был конец резки
  -- и v_ruchya содержит актуальную длину ручья
  DBMS_OUTPUT.PUT_LINE('L_ручья = ' || v_ruchya);
END;
Первый раз v_ruchya будет рассчитана корректно:
L_ручья = L_общ – L_рез_энк.
При последующих резах процедура автоматически учтёт все ранее отрезанные куски за счёт накопления cum_lrez.

В таблице ruchya_log сохранятся все моменты “окончания реза” с входными и вычисленными значениями.















Техническое задание (ТЗ) на интерфейс маркировочной машины (МВР) для участка резки первичных заготовок ножницами на вторичные по наряд-заданию
1. Общие сведения
Назначение интерфейса: управление и контроль процесса резки первичных заготовок на вторичные согласно наряд-заданию, поступающему на участок.

Пользователи: операторы участка резки, наладчики, контролеры качества.

Среда эксплуатации: промышленное производство, взаимодействие с производственными ножницами и системой учета нарядов.

2. Функциональные требования
2.1 Прием и отображение наряд-заданий

Интерфейс должен принимать наряд-задания с параметрами резки (количество, размеры, допуски).

Отображение текущего наряда с возможностью просмотра деталей и статуса выполнения.

2.2 Управление процессом резки

Отображение текущего состояния заготовки: первичная, в процессе резки, вторичная.

Визуализация этапов резки с указанием точек разреза и параметров ножниц.

Возможность запуска, паузы и остановки процесса резки оператором.

2.3 Контроль и диагностика оборудования

Отображение состояния ножниц (режущие элементы, зазоры, заточка).

Вывод предупреждений о необходимости обслуживания или замены ножей (с учетом параметров, например, зазор не более 0.5 мм).

Логирование событий и ошибок с возможностью просмотра истории.

2.4 Ввод и корректировка параметров резки

Возможность корректировки параметров наряда (например, припуск на резку, количество).

Настройка параметров резки в соответствии с технологическими требованиями (например, зазор ножей по толщине листа).

2.5 Интерактивная визуализация

Графическое отображение заготовок и линий реза с возможностью масштабирования и детализации.

Отображение координат и положения ножниц относительно заготовки.

3. Требования к интерфейсу пользователя
Адаптивный дизайн для удобства работы на промышленном сенсорном дисплее.

Интуитивно понятное меню с иерархической структурой (главное меню, подменю нарядов, настройки, диагностика).

Функциональные кнопки для быстрого доступа к основным операциям (запуск, пауза, сброс координат).

Отображение ключевой информации в реальном времени: статус резки, текущий наряд, предупреждения.

Возможность работы с USB-носителями для загрузки/выгрузки нарядов и отчетов.

4. Технические требования
Совместимость с контроллерами ЧПУ, обеспечивающими управление ножницами (по аналогии с промышленными контроллерами резки).

Поддержка загрузки и обработки нарядов в стандартном формате (например, G-коды или внутренний формат).

Обеспечение плавного управления ножницами с учетом технологических параметров резки (зазоры, скорость реза).

Логирование и хранение данных о выполненных нарядах и параметрах резки для последующего анализа.

5. Безопасность и надежность
Защита от несанкционированного доступа к управлению и настройкам.

Возможность аварийной остановки процесса резки.

Уведомления об ошибках и неисправностях с рекомендациями по устранению.

6. Дополнительные пожелания
Возможность интеграции с системой учета производства и маркировки.

Гибкая настройка интерфейса силами заказчика (смена языка, отображаемых параметров).

Поддержка обновления программного обеспечения без остановки производства.
