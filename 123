function markedCount(dataRuchej, tableinf) {
  console.log("=== Начало markedCount (массив объектов) ===");

  // 1. Подсчитываем количество объектов с каждым id (не более 100 итераций)
  const counts = {};
  console.log("Подсчет количества объектов в dataRuchej...");

  for (let i = 0; i < dataRuchej.length; i++) {
    if (i >= 100) {
      console.log(`Прерывание цикла dataRuchej: достигнуто 100 итераций (итерация ${i}).`);
      break;
    }
    const currentId = dataRuchej[i].id;
    counts[currentId] = (counts[currentId] || 0) + 1;
    console.log(
      `dataRuchej[${i}]: id=${currentId}, текущее количество для этого id = ${counts[currentId]}`
    );
  }

  console.log("Подсчет завершен, объект counts:", counts);

  // 2. Обходим tableinf (не более 100 итераций), пропускаем id="p_new", обновляем marked остальным
  console.log("Обновление поля marked в tableinf...");

  for (let i = 0; i < tableinf.length; i++) {
    if (i >= 100) {
      console.log(`Прерывание цикла tableinf: достигнуто 100 итераций (итерация ${i}).`);
      break;
    }

    const currentId = tableinf[i].id;
    if (currentId === "p_new") {
      console.log(`tableinf[${i}]: id=p_new — пропускаем обновление (не меняем marked).`);
      continue;
    }

    if (counts.hasOwnProperty(currentId)) {
      // Если есть в counts, ставим соответствующее значение
      tableinf[i].marked = counts[currentId];
      console.log(
        `tableinf[${i}]: id=${currentId} — поле marked обновлено: ${tableinf[i].marked}`
      );
    } else {
      // Иначе ставим 0
      tableinf[i].marked = 0;
      console.log(
        `tableinf[${i}]: id=${currentId} — отсутствует в counts, поле marked установлено в 0`
      );
    }
  }

  console.log("Итоговое состояние tableinf (массив объектов):", tableinf);

  // 3. Передаём полный обновленный tableinf на сервер
  console.log("Передача обновленного tableinf на сервер...");
  updateDataOnServer(tableinf);
  console.log("=== Завершение markedCount ===");
}
