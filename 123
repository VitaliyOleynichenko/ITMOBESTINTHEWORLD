function markedCount(dataRuchej, tableinf) {
  console.log("=== Начало markedCount ===");

  // 1. Подсчитываем количество объектов с каждым id в dataRuchej (ограничение до 100 итераций)
  const counts = {};
  console.log("Подсчет количества объектов по id в dataRuchej...");
  for (let i = 0; i < dataRuchej.length; i++) {
    if (i >= 100) {
      console.log(`Прерывание цикла dataRuchej: достигнуто 100 итераций (итерация ${i}).`);
      break;
    }
    const currentId = dataRuchej[i].id;
    counts[currentId] = (counts[currentId] || 0) + 1;
    console.log(`dataRuchej[${i}]: id=${currentId}, текущее количество = ${counts[currentId]}`);
  }
  console.log("Подсчет завершен, объект counts:", counts);

  // 2. Обновляем поле marked в tableinf (ограничение до 100 итераций)
  //    При этом сохраняем все существующие поля
  console.log("Обновление поля marked в tableinf...");
  for (let i = 0; i < tableinf.length; i++) {
    if (i >= 100) {
      console.log(`Прерывание цикла tableinf: достигнуто 100 итераций (итерация ${i}).`);
      break;
    }
    const currentId = tableinf[i].id;
    if (counts.hasOwnProperty(currentId)) {
      tableinf[i].marked = counts[currentId];
      console.log(`tableinf[${i}]: id=${currentId} — поле marked обновлено: ${tableinf[i].marked}`);
    } else {
      // Если для данного id нет значений в dataRuchej, устанавливаем marked в 0
      tableinf[i].marked = 0;
      console.log(`tableinf[${i}]: id=${currentId} — значение отсутствует, поле marked установлено в 0`);
    }
  }

  console.log("Обновленное tableinf:", tableinf);

  // 3. Передаем полный обновленный tableinf (с сохраненными всеми полями) на сервер
  console.log("Передача полного обновленного tableinf на сервер...");
  updateDataOnServer(tableinf);
  console.log("=== Завершение markedCount ===");
}
